{% extends "base.html.twig" %}

{% block title %}report{% endblock %}

{% block body %}
    <ul class="report-navigation">
        <li><a href="#kmom01">Kmom01</a></li>
        <li><a href="#kmom02">kmom02</a></li>
        <li><a href="#kmom03">kmom03</a></li>
        <li><a href="#kmom04">kmom04</a></li>
        <li><a href="#kmom05">kmom05</a></li>
        <li><a href="#kmom06">kmom06</a></li>
    </ul>
    <section class="reports">
        <div id="kmom01" class="report-card">
            <h3>Kmom01</h3>
            <p> 
                Jag är sedan tidigare relativt van vid att arbeta objektorienterat och har gjort detta även i PHP.
                Mest har jag använt det i Pimcore och Wordpress men det har även förekommit att jag använt det utan ramverk.
                <br><br>
                När jag ser till den grundkunskap som en utvecklare måste ha för att börja arbeta objektorienterat så anser jag att
                distinktionen av klass och objekt är viktig. Om utvecklaren vet vad skillnaden på ett objekt och klass är så kan
                denna med relativ lätthet skapa en klass och instansiera ett objekt från den samma. Dessutom är det viktigt att
                utvecklaren förstår skillanden mellan attribut och metoder, främst för att kunna separera beteende och egenskap.
                <br><br>
                Gällande kodbasen i report och frågan angående den så finns det potentiellt många saker att analysera.
                Det är lite oklart exakt vad för information som efterfrågas så jag väljer att kommentera strukturen kort och översiktligt.
                Den liknar strukturen från andra MVC-ramverk och är förhållandevis förutsägbar utan några egenskaper som sticker ut.
                <br><br>
                Angående "PHP the right way" så är det kodstil och testning som intresserar mig mest. Jag tycker ofta att testning
                hamnar i skymundan och att detta medför stora problem ju större en applikation blir. Jag själv är inte så bra på testning
                men skulle gärna sätta mig in i olika metoder för att på bästa sätt testa applikationer. Kodstil har jag på det senaste
                börjat värdera högt. Det är inte sällan man stöter på kod på internet som ibland är, i det närmaste, oläslig för att
                rekommendationer inte följs. Mitt mål är att bli bättre på att skriva lättläslig kod som också fungerar på ett tillfredsställande sätt.
                <br><br>
                Mitt TIL för detta kursmoment är traits. Jag har sedan innan inte använt mig av dessa så det skall blir spännande att sätta sig in i det.

            </p>
        </div>
        <div id="kmom02" class="report-card">
            <h3>kmom02</h3>
            <p> 
                Jag börjar med en kortfattad beskrivning av de olika OOP-koncept vi gått igenom i KMOM02:
                <br><br>
                <strong>Arv</strong>
                När en klass ärver från en annan så får den tillgång till alla ickeprivata attribut och metoder som föräldraklassen har.
                Den ärvande klassen får således samma beteende som föräldern och kan dessutom lägga till mer funktionalitet specifikt för den.
                <br><br> 
                <strong>Komposition</strong>
                Komposition och aggregation är två sätt att beskriva hur "bunda" klasser är till varandra.
                Om en klass relaterar till en annan med komposition så innebär det att en instans av denna inte kan existera på egen hand.
                Den kan bara existera i den klassen som den är medlem av.
                <br><br>
                <strong>Interface</strong>
                Ett interface beskriver ett kontrakt som en klass måste uppfylla. Specifikt beskriver den vilket beteende (metoder)
                en klass skall ha och inte vilka attribut (egenskaper) den skall ha. Om två klasser extendar ett interface så kan
                man vara säker på att båda klasserna minst uppfyller de beteenden som interfacet definierar.
                <br><br>
                <strong>Trait</strong>
                Trait finns till i PHP eftersom det inte stöder multipelt arv. Genom att använda traits så kan man definiera metoder som flera klasser kan använda sig av,
                oavsett om de är besläktade med varandra eller inte. Traits möjliggör därför flera klasser att ha samma beteende utan att behöva definiera samma metoder
                i alla dessa klasser.
                <br><br>
                <strong>Implementering</strong>
                Angående implementeringen av uppgiften så anser jag att den gick utan svårigheter. Jag är nöjd med min insats och programmet fungerar till belåtenhet.
                För att lösa uppgiften började jag med att skriva ner i vilken ordning jag skulle utföra saker. Dessutom specificerade jag vilka attribut och metoder
                som min klasser skulle ha för att önskat beteende skulle kunna uppnås. Därefter skapade jag en båda kontrollers och sidmallarna som skulle hysa alla data.
                När jag var klar med dessa moment började jag implementera attribut och metoder i mina klasser och skapade sedan routes som renderade sidmallar med data på.
                En förbättring jag ser är att tillåta användaren att blanda Card och CardGraphic i samma kortlek.
                Dock såg jag detta som lite överflödigt då CardGraphic erbjuder samma funktionalitet som Card.
                <br><br>
                Angående flödesdiagram och pseudokod så var det inget som uppgiften bad om. Därför tänkte jag i denna diskussion utgå från mitt UML-diagram.
                Jag tycker ofta att det är bra att modellera klasser i ett UML-diagram innan dessa implementeras.
                Genom att göra det kan jag abstrahera bort en hel del och enbart fokusera på hur klasserna skall se ut och bete sig,
                utan att behöva störas av hur de skall implementeras konkret. Jag tror definitivt att detta är ett stöd och att det förbättrar min problemlösningsförmåga.
                <br><br>
                Min TIL för detta kursmoment är en bättre förståelse för Symfony samt hur jag lägger till skräddarsytt beteende för json-serialisering på klassnivå.
            </p>
        </div>
        <div id="kmom03" class="report-card">
            <h3>Kmom03</h3>
            <p> 
                Jag tycker att Kmom03 har givit mig goda förutsättningar att öva på modellering och problemlösning med pseudokod och flödesdiagram. Jag anser att det har varit till stor nytta för mig och att det dessutom ökat kvaliteten på den kod jag producerat. Att modellera en applikation och tänka igenom den nog innan implementering är något som jag kommer att fortsätta med framöver. Jag anser att det hjälper mig i min problemlösning och att det asbtraherar bort implementeringsspecifika detaljer som annars kan sätta käppar i hjulen för problemlösningen i sig.
                <br><br>
                Gällande min implementering av kortspelet så tänkte jag först noga över hur jag skulle lösa uppgiften. Sedan började jag att översiktligt specificera vilka delar jag skulle lösa först. Därefter började jag skissa på de olika klassernas beteende och egenskaper, för att slutligen implementera dessa i en bestämd ordning. Jag fick göra en del justeringar under utvecklingen vilket händer mig i det flesta kursmoment. Justeringarna i detta kmom är sådana som har med spelets tillstånd att göra och ett exempel på detta är "CardGame::updateGameState()". Jag ville att hela spelets tillstånde skulle kunna uppdateras i en enda funktion och inte i flera separata funktioner.  Med hjälp av denna funktion uppnådde jag mitt mål och spelet blev lätt att hantera, utan rörig kod. Några saker som skulle kunna förbättras är CardGame::getWinner(), som är alldeles för rörig, och updateDealer / updatePlayer från samma klass. De två sistnämda borde jag kunna göra i en enskild funktion men har inte hittat något bra sätt att åstadkomma det på.
                <br><br>
                Hittills i kursen så tycker jag att Symfony som ramverk har varit ett stöd för mig. Det gör mycket bakom kulisserna och en hel del går på "automagi". Fördelen med detta är att jag slipper att tänka på implementeringsspecifika detaljer som annars hade tagit en del tid att utveckla på egen hand. Jag tycker att templatingsystemet fungerar bra men saknar intellisense i twigfilerna. Det hade underlättat att ha typinferens / autocomplete direkt i templates ungefär så som React / Vue med typescript fungerar. Dessa två är ju dock frontend-ramverk / -paket och inte baserade på PHP men man kan ju alltid önska.
                Jag är nöjd med min insats i kmom03 och anser att jag gjort det mesta med den tid jag hade disponibel. Mitt TIL för detta kursmoment är kodstandard och struktur i PHP samt tankesättet med tunna controllers och feta modeller.

            </p>
        </div>
        <div id="kmom04" class="report-card">
            <h3>Kmom04</h3>
            <h4>Enhetstestning</h4>
            <p> 
                <br><br>
                Detta kursmoment har varit ett av de nyttigaste i kursen hittills. Jag har fått insikt om vad testning i PHP med PHPunit innebär samt hur tester struktureras och konfigureras. Sedan innan har jag skrivit enhetstester i Node, Python och C# och det är intressant hur lik testprocessen är. Därför tycker jag att testning med PHPUnit har känts naturligt och lättsamt. Konfigurationen av programvaran har också gått utan problem och jag tycker att mycket varit intuitivt.
                <br><br>
                Gällande att skriva kod som testar annan kod så tycker jag att det är olika lätt / svårt beroende på hur koden som skall testas ser ut. Om det exempelvis finns mycket slumpmässigt beteende i funktioner så tycker jag att det är otroligt svårt att få till bra testfall. Om det däremot är fastställt vad en funktion skall returnera så är det ofta trivialt att testa den.
                <br><br>
                När jag ser till kodtäckning så lyckades jag få 100% i flera av mina klasser. Den enda som jag inte uppnådde detta i var CardGame, vilket berodde på att den har en del icke deterministiskt beteende som sätter rätt rejäla käppar i hjulen. Jag experimenterade med Mock objects och Stubs för att kunna simulera slumpmässigt beteende men kom snabbt fram till att de testfall där dessa användes inte var så meningsfulla. Därför slopade jag en del tester som jag inte ansåg uppfyllde ett syfte.
                <br><br>
                Jag tycker generellt att min kod är testbar och jag stötte inte på några problem bortsett från de som jag beskrev i föregående stycke. Jag skulle kunna åtgärda slumpmässiga beteenden för att göra koden mer testbar, men i detta sammanhang så skulle detta resultera i förlust av funktionalitet som faktiskt behövs för att applikationen skall fungera som tänkt. Med det sagt så valde jag trots allt att skriva om en del annan kod för att det skulle vara lättare att förstå den och därmed lättare att formulera testfall för. Den funktion som jag skrev om mest var CardGame::getWinner(), som i sitt grundutförande var nästintill obegriplig och onödigt komplicerad för vad den gjorde.
                <br><br>
                Om jag skall reflektera lite om hurvida testbar kod per automatik innebär "snygg och ren" kod så tänker jag att det beror på. Bara för att en funktion är lätt att testa så behöver det inte betyda att den är snyggt och strukturerat skriven. Exempelvis skulle funktionen kunna manipulera data på alla möjliga komplicerade sätt innan den till slut returnerar ett värde. Returvärdet i sig kanske enbart kan ha två former medans koden som bestämmer vilken form detta skall ha kan vara otroligt komplex. I ett sådant fall blir funktionen lätt att testa men svår att förstå sig på. Samtidigt skulle man kunna argumentera för att det i ett sådant fall vore intressant att göra fler "del-assertions" inne i funktionen för att kontrollera att data manipuleras på rätt sätt. Vilket i sådana fall skulle göra koden mer svårtestad och därmed stärka sambandet mellan testbar och snygg/strukturerad kod.
                <br><br>
                Mitt TIL för detta kursmoment är upplägget på testklasser med PHPUnit samt hur programvaran konfigureras.
            </p>
        </div>
        <div id="kmom05" class="report-card">
            <h3>Kmom05</h3>
            <h4>ORM</h4>
            <p> 
                <br><br>
                Övningen med symfony och doctrine gick bra att genomföra och jag kände igen upplägget från att ha arbetat med andra ORM.  Det är trevligt att kunna abstrahera bort interaktionen mot databasen och få ett mer deklarativt sätt att hantera denna istället. Något som jag tänkte på under övningen, som dock inte har med ORM specifikt att göra, är hur förvirrande OOP lätt blir när en klass ärver från mer än en klass i en kedja. Blandar man dessutom in interface så tycker jag att det lätt blir oöverskådligt och svårt att navigera i källkod för att hitta ärvda metoder. Detta är bara en kort reflektion om något som jag spontant kände under tiden jag arbetade med momentet och det har som sagt inget att göra med ORM specifikt utan snarare paradigmen i sig.
                <br><br>
                Gällande applikationen så gjorde jag den så enkel som möjligt. Målet var att det så få knapptryck som möjligt skall behövas när en användare skall kunna uträtta en uppgift. Jag försökte få interfacet så intuitivt som möjligt och även om det lämnar mycket att önska i form av design så är funktionaliteten där. Det enda stället som jag kände att jag behövde förtydliga var i tabellen med alla böcker. För att komma till en enskild bok så måste användaren klicka på id:t, men det framgår inte omedelbart i UI:t. Därför lade jag till en text över tabellen som förklarar hur användaren skall navigera. Dock så hade det troligtvis varit mer lämpligt att populera id-kolumnen med en grön knapp men den befintliga lösningen fungerar sannolikt också. Sammantaget så anser jag ändå att gränssnittet är relativt intuitivt och fungerar bra för vad det är.
                <br><br>
                När jag ser till att arbeta med ORM i CRUD så tycker jag att det abstraherar bort mycket av sådant som tar tid. Dessutom blir interaktionen med databasen mer deklarativ och jag slipper skriva SQL för varenda operation. Förutom detta så får jag också ett bra sätt att uppdatera databasens schema på, och behöver inte köra ALTER TABLE-statements för att lägga till ytterligare fält. Istället sköter ORM det åt mig med hjälp av migrationer, något som sparar mycket tid i kodskrivande och testande.
                <br><br>
                Sammanfattningsvis så ser jag ORM som ett bra sätt att abstrahera bort mycket av det som är besvärligt med databaser. Samtidigt förstår jag också att viss flexibilitet försvinner. Skulle det vara så att man kräver något som ens entiteter inte klarar av så är man dock fri att använda rå SQL, även om detta till viss det tar bort poängen med ett ORM. Effekten av att arbeta med ett ORM är att antalet kodrader som behövs minskar drastiskt. Som jag tidigare nämt så behöver man inte längre skriva långa SQL-satser utan kan i stället njuta av ett enkelt och lättförstått gränssnitt mot databasen.
                <br><br>
                Mitt TIL för detta kmom är hur frustrerande det kan vara med arv i många led samt hur doctrine fungerar och underlättar interaktion mot en databas.
            </p>
        </div>
        <div id="kmom06" class="report-card">
            <h3>Kmom06</h3>
            <p> 
                <strong>KMOM 06</strong>
                Jag tycker att phpmetrics är en trevlig programvara som jag kan se mig själv använda i framtiden om jag använder PHP. Det ger värdefulla insikter och strukturerar informationen på ett bra sätt, även om jag önskar att det fanns bättre förklaringar av de saker den mäter. Under kursmomentets gång fick jag googla en hel del och ta information från externa sidor för att förstå innebörden av mätvärdena. Trots detta tycker jag programmet fungerar bra i sin helhet. Jag fastnade framförallt för relativ systemkomplexitet eftersom denna tar hänsyn till alla metoder i en klass samt komplexiteten dessa i mellan. Det är ett bra mått på hur en komplex en komponent är i genomsnitt och därmed ett bra mått på hur lätt / svår den är att underhålla. En annan funktion som jag blev förtjust i är Mantainability / complexity på phpmetrics "Overview"-sida. Där kan man se olika stora cirklar i olika färger som symboliserar cyklomatisk komplexitet samt "maintainability index".
                <br><br>
                Gällande scrutinizer så gick integrationen mot mitt repo relativt smärtfritt. Jag hade en del problem med att scrutinizer inte kunde köra composer install. Det visade sig bero på en avsaknad av env-fil i repot, något som jag hade konfigurerat tidigt i projektets skede. När denna väl var på plats så fungerade vertyget som väntat. Efter att ha använt vertyget ett tag så skulle jag säga att jag utan tvekan kommer koppla detta mot andra projekt när tillfälle uppenbarar sig. Det är synnerligen värdefullt med automatisk testning och emblemen som kan läggas till i readmefilen är en trevlig bonus de också. Jag uppnådde 36% i kodtecking i min första körning samt 9.97 / 10 i kodkvalitet.
                <br><br>
                Gällande kodkvalitet och min syn på den så har jag några saker jag brukar tänka på när begreppet tas upp. Jag tycker att det mest grundläggande är att skriva kod som är lätt att underhålla och som i princip dokumenterar sig själv. Jag anser att det är viktigt att inte fastna i tanken om att man skall skriva så kompakt kod som möjligt, utan att denna istället skall vara lätt att förstå och göra ändringar i. Dessutom tycker jag att man bör kommentera sin kod lagom, så att inte kommentarerna i sig gör koden besvärlig att läsa. Allmänt tycker jag att det är bättre att kommentera varför man gör något och inte vad man gör. Undantag finns, så som docblocks i PHP. Sedan tror jag också att testning är en central del av att faktiskt verifiera att ens kod håller den standard som man själv tror att den gör. Att också få ett bevis på detta i form av badges är ett bra sätt att informera andra om att ens kod håller en viss kvalitet.
                <br><br>
                Mitt TIL för detta kursmoment är hur jag kopplar ihop ett repo med Scrutinizer samt hur jag tyder de resultat som phpmetrics producerar.
            </p>
        </div>
        <div id="kmom10" class="report-card">
            <h3>Kmom10</h3>
            <p> 
                <strong>Grunden</strong>
                Jag valde i mitt slutprojekt att skapa ett pokerspel. Pokerspelet är av typen Femkortspoker som också är den typ jag spelade med min Farmor när jag var liten.
                I denna text skall jag beskriva och motivera mina tankar inför projektet samt den process jag följde i implementeringen av spelet.
                <br>
                När jag inledde projektet var min spontana idé att göra just ett pokerspel. Jag tänkte att en del av funktionaliteten redan existerade sedan tidigare
                kursmoment och att jag nu skulle kunna utnyttja dessa till ett nytt projekt. Min tanke var att det skulle bli ett bra test för hur flexibla och
                väl konstruerade mina tidigare klasser var samt hur lätta dessa skulle bli att justera under projektets gång. Innan jag började med implementeringen
                av själva spelet så skapade jag nya sidmallar som placerades i en helt ny mapp. Sedan skapade jag nya sass- samt js-filer för att kunna separera frontend-funktionalitet
                samt utseende på sidan. När jag väl var klar med det konstruerade jag en minimalistisk landningssida med tydlighet och användbarhet som ledord. Jag var noga
                med att designen skulle skilja sig från grundtemat på hemsidan och att den skulle ge ett helt annat intryck än den förstnämnda.
                <br><br>
                <strong>Flödet</strong>
                Därefter började jag planera mina routes och hur grundflödet i pokerspelet skulle se ut, något som utmynnade i `PokerController.php`. Med erfarenhet och kunskap
                förvärvad genom arbetet med `CardGameController.php`, så visste jag redan från början hur jag ville att `PokerController.php` skulle se ut. Min vision var
                att en route skulle hantera rendering av sidmall och att de andra skulle vidarebefordra requests till 'huvudrouten' efter att dessa manipulerat själva pokerinstansen. Tanken bakom
                beslutet var att det skulle bli lättare att visualisera flödet i applikationen, som jag misstänkte skulle kunna bli förhållandevis omfattande
                med avseende på alla de beslut som en pokerspelare kan ta i olika situationer. Dessutom tänkte jag att det också skulle bli lättare att spåra pokerspelets tillstånd, då det skulle bli
                lätt att skriva ut instansens innehåll vid en specifik plats i programmet. Med denna specifikation i bakhuvudet började jag implementera pokerspelets routing.
                <br><br>
                <strong>Spellogik och tillstånd</strong>
                Med kontrollern på plats började jag planera själva pokerspelets funktionalitet. Sedan tidigare i kursen visste jag att jag den största utmaningen skulle bli att hantera
                pokerspelets tillstånd, exempelvis vilken spelare det är och vilken runda det är. Därför började jag med att tänka på de åtgärder från spelaren där uppdatering av spelets
                tillstånd skulle bli nödvändigt. Förutsägbart nog var dessa åtgärder `lägga sig`, `passa`, `syna` samt `höja / satsa`. Dessa var också de första funktioner jag implementerade
                eftersom jag ansåg att de skulle bli så centrala att de tvunget behövde finnas redan från början. Därefter började jag fundera på hur själva tillståndet faktiskt skulle uppdateras
                och kom fram till en lösning som tog inspiration från mitt första kortspel (21). Idén var att jag skulle köra en funktion efter varje speluppdatering med syftet att tillståndet alltid
                skulle vara uppdaterat. Fördelen med detta var att allt skulle uppdateras på samma ställe och att tillståendet därför inte skulle behöva updateras på flera olika ställen.
                Sagt och gjort, jag implementerade funktionen PokerGame::updateGameState() där alla uppdateringar skulle ske. I efterhand så kan man dock se att spelets tillstånd uppdateras på flera olika ställen
                men dessa ändringar är ofta kopplade till åtgärder som sker direkt på spelar- och dealer-objektet. Deras tillstånd kontrolleras i sin tur i PokerGame::updateGameState().
                <br><br>
                <strong>Poängsättning av avgörande av vinnare</strong>
                Efter att PokerGame och PokerController var klara så började jag slipa på den del som jag från början fruktat mest, funktionalitet för att poängsätta de olika pokerhänder en spelare kan få.
                Jag visste att denna funktionalitet inte skulle rymmas i PokerGame och jag visste dessutom att funktionaliteten inte skulle kräva ett specifikt bibehållet tillstånd, det vill säga att
                varje gång en pokerhand utvärderas så gör den det utan beroende från ett specifikt tillstånd i spelet. Det enda jag skulle behöva göra beslut på var den faktiskt pokerhanden, som i sig är en instans av CardHand.
                Med denna insikt konstruerade jag en statisk klass med ett enda syfte, att returnera vinnaren från aktuellt pokerspel. Klassen fick namnet PokerHandEvaluator vars centrala metod tar in en lista med spelare.
                Varje spelares korthand evalueras sedan i PokerHandEvaluator::evaluateHandValue, varpå en vinnare utses. För att göra poängsättningen enkel så skapade jag också en enkel klass vid namn `HandRank` där varje
                korthand mappas till ett bestämt siffervärde.
                <br><br>
                <strong>Krav 4: JsonAPI</strong>
                <br>
                I projektets linda hade jag redan hunnit fundera en del på hur kortbytet egentligen skulle gå till. Först tänkte jag att jag skulle placera korten
                som element med checkboxes under och sedan skicka in dessa som ett formulär. Dock kände jag lösningen skulle bli lite tråkig och jag tog därför beslutet
                att låta kortbytet ske dynamiskt med hjälp av javascript på klientsidan. Inte nog med att jag skulle få mer variation i projektet, jag skulle också behöva
                implementera ett JsonAPI vilket ändå var en del projektets krav. Med det sagt så implementerade jag klassen PokerGame i PokerGame.js där jag bland annat
                inkluderade funktionalitet för att fästa event listeners på spelplanens kort. Jag lade också till en enkel wrapperfunktion till javascripts inbyggda fetch-funktion med avsikt att underlätta API-frågor från andra funktioner i klassen.
                Därefter skapade jag funktionen 'submitCards' som skulle titta på spelplanen och skicka med de kort som spelaren valt att byta ut. När klientsidan var klar vände jag mig mot
                servern där en ny kontroller behövde implementeras. Jag döpte den till APIPokerController och lade till nödvändiga endpoints för att javascript-funktionerna skulle fungera.
                <br><br>
                Den mest centrala delen i API:t är metoden APIPokerController::changeCards. Den tar in en lista som innehåller heltal som motsvarar ett korts position i handen.
                Denna lista skickas sedan vidare till PokerGame::currentPlayerChangeCard där korten byts ut baserat på vilka index som skickats med. Om allt går bra så skickas en JsonResponse med
                spelarens nya korthand tillbaka, annars skickas ett meddelande om att något gått fel. Spelarens ny korthand används sedan på klientsidan för att populera spelplanen
                med nya kort.

                <br><br>
                Gällande de routes jag valde att lägga till i API:t så är dessa som följer:
                <br><br>
                <strong>1. Hämta nuvarande spelare</strong>
                <br>
                <strong>2. Hämta nuvarande spelares namn</strong>
                <br>
                <strong>3. Hämta dealerns namn</strong>
                <br>
                <strong>4. Hämta nuvarande runda</strong>
                <br>
                <strong>5. Sätt nuvarande spelares pengar till ett värde som anges i inputfältet</strong>

                <br><br>
                <strong>Avslutningsvis</strong>
                <br>
                Jag ångrar ganska mycket att jag valde pokerspelet och jag tror att jag underskattade komplexiteten i det. Jämfört med 21
                så är pokerspelet flera storleksordningar upp i komplexitet, enligt mig. På åtta kurser så är detta det enda projekt jag haft besvär med och
                i princip allt har krånglat. Exempelvis så har jag fått anpassa mina test till scrutinizer så att dessa inte skall krascha där. Det verkar som att
                det inte kan hantera när testerna returnerar HTML. Dessutom har jag också fått instansiera egna Kernels i de tester som använder WebTestCase eftersom
                scrutinizer kraschar annars. Jag tycker också att det har varit mycket svårt att hitta bra tips på scrutinizer online och jag tycker heller inte dokumentationen
                är särskilt tillfredsställande. Sedan tycker jag att enhetstesterna i sig har varit ett stressmoment. De klasser jag har fått bygga har till stor del slumpmässigt beteende
                och det är därför svårt och kanske inte ens meningsfullt att testa visst beteende. Med det sagt så har jag gjort mitt absolut bästa och försökt konstruera meningsfulla test
                i den mån det har varit möjligt, även om jag inte uppnått över 90%. Jag anser dock att de tester jag har täcker den deterministiska funktionalitet som
                är kritiskt för att pokerspelet skall fungera som tänkt. Om jag hade haft mer tid så skulle jag fokusera ännu mer på testerna för att uppnå den nivå jag önskar.
                <br><br>
                För övrigt tycker jag att projektet har varit stressigt, främst på grund av hur scrutinizer betett sig (har säkert lagt 20% av tiden enbart på att bråka med det),
                men också för att jag känner att jag valt fel projekt. Dessutom har jag aldrig skrivit så mycket kod på så kort tid förut enhetstesterna har krävt ordentlig insats att få till.
                Trots detta lyckades jag trots allt med ett kortspel som fungerar på ett tillfredsställande sätt, vilket får bli trösten i sammanhanget.
                I de åtta kurser jag haft hittills så har detta projekt krävt mest engagemang men också bidragit till mest frustration. Som jag nämnt tidigare har scrutinizer
                varit ett konstant överhängande hot om krångel vilket inte var särskilt angenämt.
                <br><br>
                När jag blickar tillbaka tycker jag ändå att jag lärt mig otroligt mycket och anser att kursen har varit till stor nytta. Jag har fått nya insikter om vad
                testning innebär och hur man på olika sätt kan använda sig av detta verktyg i jakt på bättre kod. Dessutom har jag fått upp ögonen för CD/CI-lösningar och
                jag tycker att konceptet demystifierats en hel del sedan jag började denna kurs. Så överlag tycker jag kursen har varit bra och som vanligt tycker jag det samma
                om materialet. Jag tycker att det har varit bra att en stor del av materialet har baserats på Symfonys egna dokumentation. Det har gjort att eget letande
                bland deras dokumentation känts mer överkomligt. Slutligen vill jag ge kursen ett gott betyg om 7/10 varav det stressiga slutprojektet står för det största
                poängtappet. Detta är min sista kurs på ett tag och jag vill tacka för ert engagemang. Jag hoppas att vi hörs någon annan gång och att ni har det bra tills dess.
                <br><br>
                Obs! Det ligger tre sviter med enhetstest som jag exkluderat i phpunit.xml.dist. Dessa fungerar alldeles utmärkt lokalt men går inte igenom på scrutinizer.
                Jag har lagt en del tid på dessa och är det så att ni önskar att köra dem så kan detta göras genom att ta bort dessa som exkluderade i phpunits konfigurationsfil.
                <strong>Linus</strong>

            </p>
        </div>
    </section>
{% endblock %}