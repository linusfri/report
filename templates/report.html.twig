{% extends "base.html.twig" %}

{% block title %}report{% endblock %}

{% block body %}
    <ul class="report-navigation">
        <li><a href="#kmom01">Kmom01</a></li>
        <li><a href="#kmom02">kmom02</a></li>
        <li><a href="#kmom03">kmom03</a></li>
        <li><a href="#kmom03">kmom04</a></li>
    </ul>
    <section class="reports">
        <div id="kmom01" class="report-card">
            <h3>Kmom01</h3>
            <p> 
                Jag är sedan tidigare relativt van vid att arbeta objektorienterat och har gjort detta även i PHP.
                Mest har jag använt det i Pimcore och Wordpress men det har även förekommit att jag använt det utan ramverk.
                <br><br>
                När jag ser till den grundkunskap som en utvecklare måste ha för att börja arbeta objektorienterat så anser jag att
                distinktionen av klass och objekt är viktig. Om utvecklaren vet vad skillnaden på ett objekt och klass är så kan
                denna med relativ lätthet skapa en klass och instansiera ett objekt från den samma. Dessutom är det viktigt att
                utvecklaren förstår skillanden mellan attribut och metoder, främst för att kunna separera beteende och egenskap.
                <br><br>
                Gällande kodbasen i report och frågan angående den så finns det potentiellt många saker att analysera.
                Det är lite oklart exakt vad för information som efterfrågas så jag väljer att kommentera strukturen kort och översiktligt.
                Den liknar strukturen från andra MVC-ramverk och är förhållandevis förutsägbar utan några egenskaper som sticker ut.
                <br><br>
                Angående "PHP the right way" så är det kodstil och testning som intresserar mig mest. Jag tycker ofta att testning
                hamnar i skymundan och att detta medför stora problem ju större en applikation blir. Jag själv är inte så bra på testning
                men skulle gärna sätta mig in i olika metoder för att på bästa sätt testa applikationer. Kodstil har jag på det senaste
                börjat värdera högt. Det är inte sällan man stöter på kod på internet som ibland är, i det närmaste, oläslig för att
                rekommendationer inte följs. Mitt mål är att bli bättre på att skriva lättläslig kod som också fungerar på ett tillfredsställande sätt.
                <br><br>
                Mitt TIL för detta kursmoment är traits. Jag har sedan innan inte använt mig av dessa så det skall blir spännande att sätta sig in i det.

            </p>
        </div>
        <div id="kmom02" class="report-card">
            <h3>kmom02</h3>
            <p> 
                Jag börjar med en kortfattad beskrivning av de olika OOP-koncept vi gått igenom i KMOM02:
                <br><br>
                <strong>Arv</strong>
                När en klass ärver från en annan så får den tillgång till alla ickeprivata attribut och metoder som föräldraklassen har.
                Den ärvande klassen får således samma beteende som föräldern och kan dessutom lägga till mer funktionalitet specifikt för den.
                <br><br> 
                <strong>Komposition</strong>
                Komposition och aggregation är två sätt att beskriva hur "bunda" klasser är till varandra.
                Om en klass relaterar till en annan med komposition så innebär det att en instans av denna inte kan existera på egen hand.
                Den kan bara existera i den klassen som den är medlem av.
                <br><br>
                <strong>Interface</strong>
                Ett interface beskriver ett kontrakt som en klass måste uppfylla. Specifikt beskriver den vilket beteende (metoder)
                en klass skall ha och inte vilka attribut (egenskaper) den skall ha. Om två klasser extendar ett interface så kan
                man vara säker på att båda klasserna minst uppfyller de beteenden som interfacet definierar.
                <br><br>
                <strong>Trait</strong>
                Trait finns till i PHP eftersom det inte stöder multipelt arv. Genom att använda traits så kan man definiera metoder som flera klasser kan använda sig av,
                oavsett om de är besläktade med varandra eller inte. Traits möjliggör därför flera klasser att ha samma beteende utan att behöva definiera samma metoder
                i alla dessa klasser.
                <br><br>
                <strong>Implementering</strong>
                Angående implementeringen av uppgiften så anser jag att den gick utan svårigheter. Jag är nöjd med min insats och programmet fungerar till belåtenhet.
                För att lösa uppgiften började jag med att skriva ner i vilken ordning jag skulle utföra saker. Dessutom specificerade jag vilka attribut och metoder
                som min klasser skulle ha för att önskat beteende skulle kunna uppnås. Därefter skapade jag en båda kontrollers och sidmallarna som skulle hysa alla data.
                När jag var klar med dessa moment började jag implementera attribut och metoder i mina klasser och skapade sedan routes som renderade sidmallar med data på.
                En förbättring jag ser är att tillåta användaren att blanda Card och CardGraphic i samma kortlek.
                Dock såg jag detta som lite överflödigt då CardGraphic erbjuder samma funktionalitet som Card.
                <br><br>
                Angående flödesdiagram och pseudokod så var det inget som uppgiften bad om. Därför tänkte jag i denna diskussion utgå från mitt UML-diagram.
                Jag tycker ofta att det är bra att modellera klasser i ett UML-diagram innan dessa implementeras.
                Genom att göra det kan jag abstrahera bort en hel del och enbart fokusera på hur klasserna skall se ut och bete sig,
                utan att behöva störas av hur de skall implementeras konkret. Jag tror definitivt att detta är ett stöd och att det förbättrar min problemlösningsförmåga.
                <br><br>
                Min TIL för detta kursmoment är en bättre förståelse för Symfony samt hur jag lägger till skräddarsytt beteende för json-serialisering på klassnivå.
            </p>
        </div>
        <div id="kmom03" class="report-card">
            <h3>Kmom03</h3>
            <p> 
                Jag tycker att Kmom03 har givit mig goda förutsättningar att öva på modellering och problemlösning med pseudokod och flödesdiagram. Jag anser att det har varit till stor nytta för mig och att det dessutom ökat kvaliteten på den kod jag producerat. Att modellera en applikation och tänka igenom den nog innan implementering är något som jag kommer att fortsätta med framöver. Jag anser att det hjälper mig i min problemlösning och att det asbtraherar bort implementeringsspecifika detaljer som annars kan sätta käppar i hjulen för problemlösningen i sig.
                <br><br>
                Gällande min implementering av kortspelet så tänkte jag först noga över hur jag skulle lösa uppgiften. Sedan började jag att översiktligt specificera vilka delar jag skulle lösa först. Därefter började jag skissa på de olika klassernas beteende och egenskaper, för att slutligen implementera dessa i en bestämd ordning. Jag fick göra en del justeringar under utvecklingen vilket händer mig i det flesta kursmoment. Justeringarna i detta kmom är sådana som har med spelets tillstånd att göra och ett exempel på detta är "CardGame::updateGameState()". Jag ville att hela spelets tillstånde skulle kunna uppdateras i en enda funktion och inte i flera separata funktioner.  Med hjälp av denna funktion uppnådde jag mitt mål och spelet blev lätt att hantera, utan rörig kod. Några saker som skulle kunna förbättras är CardGame::getWinner(), som är alldeles för rörig, och updateDealer / updatePlayer från samma klass. De två sistnämda borde jag kunna göra i en enskild funktion men har inte hittat något bra sätt att åstadkomma det på.
                <br><br>
                Hittills i kursen så tycker jag att Symfony som ramverk har varit ett stöd för mig. Det gör mycket bakom kulisserna och en hel del går på "automagi". Fördelen med detta är att jag slipper att tänka på implementeringsspecifika detaljer som annars hade tagit en del tid att utveckla på egen hand. Jag tycker att templatingsystemet fungerar bra men saknar intellisense i twigfilerna. Det hade underlättat att ha typinferens / autocomplete direkt i templates ungefär så som React / Vue med typescript fungerar. Dessa två är ju dock frontend-ramverk / -paket och inte baserade på PHP men man kan ju alltid önska.
                Jag är nöjd med min insats i kmom03 och anser att jag gjort det mesta med den tid jag hade disponibel. Mitt TIL för detta kursmoment är kodstandard och struktur i PHP samt tankesättet med tunna controllers och feta modeller.

            </p>
        </div>
        <div id="kmom04" class="report-card">
            <h3>Kmom04</h3>
            <h4>Enhetstestning</h4>
            <p> 
                <br><br>
                Detta kursmoment har varit ett av de nyttigaste i kursen hittills. Jag har fått insikt om vad testning i PHP med PHPunit innebär samt hur tester struktureras och konfigureras. Sedan innan har jag skrivit enhetstester i Node, Python och C# och det är intressant hur lik testprocessen är. Därför tycker jag att testning med PHPUnit har känts naturligt och lättsamt. Konfigurationen av programvaran har också gått utan problem och jag tycker att mycket varit intuitivt.
                <br><br>
                Gällande att skriva kod som testar annan kod så tycker jag att det är olika lätt / svårt beroende på hur koden som skall testas ser ut. Om det exempelvis finns mycket slumpmässigt beteende i funktioner så tycker jag att det är otroligt svårt att få till bra testfall. Om det däremot är fastställt vad en funktion skall returnera så är det ofta trivialt att testa den.
                <br><br>
                När jag ser till kodtäckning så lyckades jag få 100% i flera av mina klasser. Den enda som jag inte uppnådde detta i var CardGame, vilket berodde på att den har en del icke deterministiskt beteende som sätter rätt rejäla käppar i hjulen. Jag experimenterade med Mock objects och Stubs för att kunna simulera slumpmässigt beteende men kom snabbt fram till att de testfall där dessa användes inte var så meningsfulla. Därför slopade jag en del tester som jag inte ansåg uppfyllde ett syfte.
                <br><br>
                Jag tycker generellt att min kod är testbar och jag stötte inte på några problem bortsett från de som jag beskrev i föregående stycke. Jag skulle kunna åtgärda slumpmässiga beteenden för att göra koden mer testbar, men i detta sammanhang så skulle detta resultera i förlust av funktionalitet som faktiskt behövs för att applikationen skall fungera som tänkt. Med det sagt så valde jag trots allt att skriva om en del annan kod för att det skulle vara lättare att förstå den och därmed lättare att formulera testfall för. Den funktion som jag skrev om mest var CardGame::getWinner(), som i sitt grundutförande var nästintill obegriplig och onödigt komplicerad för vad den gjorde.
                <br><br>
                Om jag skall reflektera lite om hurvida testbar kod per automatik innebär "snygg och ren" kod så tänker jag att det beror på. Bara för att en funktion är lätt att testa så behöver det inte betyda att den är snyggt och strukturerat skriven. Exempelvis skulle funktionen kunna manipulera data på alla möjliga komplicerade sätt innan den till slut returnerar ett värde. Returvärdet i sig kanske enbart kan ha två former medans koden som bestämmer vilken form detta skall ha kan vara otroligt komplex. I ett sådant fall blir funktionen lätt att testa men svår att förstå sig på. Samtidigt skulle man kunna argumentera för att det i ett sådant fall vore intressant att göra fler "del-assertions" inne i funktionen för att kontrollera att data manipuleras på rätt sätt. Vilket i sådana fall skulle göra koden mer svårtestad och därmed stärka sambandet mellan testbar och snygg/strukturerad kod.
                <br><br>
                Mitt TIL för detta kursmoment är upplägget på testklasser med PHPUnit samt hur programvaran konfigureras.
            </p>
        </div>
    </section>
{% endblock %}