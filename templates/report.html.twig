{% extends "base.html.twig" %}

{% block title %}report{% endblock %}

{% block body %}
    <ul class="report-navigation">
        <li><a href="#kmom01">Kmom01</a></li>
        <li><a href="#kmom02">kmom02</a></li>
        <li><a href="#kmom03">kmom03</a></li>
        <li><a href="#kmom04">kmom04</a></li>
        <li><a href="#kmom05">kmom05</a></li>
        <li><a href="#kmom06">kmom06</a></li>
    </ul>
    <section class="reports">
        <div id="kmom01" class="report-card">
            <h3>Kmom01</h3>
            <p> 
                Jag är sedan tidigare relativt van vid att arbeta objektorienterat och har gjort detta även i PHP.
                Mest har jag använt det i Pimcore och Wordpress men det har även förekommit att jag använt det utan ramverk.
                <br><br>
                När jag ser till den grundkunskap som en utvecklare måste ha för att börja arbeta objektorienterat så anser jag att
                distinktionen av klass och objekt är viktig. Om utvecklaren vet vad skillnaden på ett objekt och klass är så kan
                denna med relativ lätthet skapa en klass och instansiera ett objekt från den samma. Dessutom är det viktigt att
                utvecklaren förstår skillanden mellan attribut och metoder, främst för att kunna separera beteende och egenskap.
                <br><br>
                Gällande kodbasen i report och frågan angående den så finns det potentiellt många saker att analysera.
                Det är lite oklart exakt vad för information som efterfrågas så jag väljer att kommentera strukturen kort och översiktligt.
                Den liknar strukturen från andra MVC-ramverk och är förhållandevis förutsägbar utan några egenskaper som sticker ut.
                <br><br>
                Angående "PHP the right way" så är det kodstil och testning som intresserar mig mest. Jag tycker ofta att testning
                hamnar i skymundan och att detta medför stora problem ju större en applikation blir. Jag själv är inte så bra på testning
                men skulle gärna sätta mig in i olika metoder för att på bästa sätt testa applikationer. Kodstil har jag på det senaste
                börjat värdera högt. Det är inte sällan man stöter på kod på internet som ibland är, i det närmaste, oläslig för att
                rekommendationer inte följs. Mitt mål är att bli bättre på att skriva lättläslig kod som också fungerar på ett tillfredsställande sätt.
                <br><br>
                Mitt TIL för detta kursmoment är traits. Jag har sedan innan inte använt mig av dessa så det skall blir spännande att sätta sig in i det.

            </p>
        </div>
        <div id="kmom02" class="report-card">
            <h3>kmom02</h3>
            <p> 
                Jag börjar med en kortfattad beskrivning av de olika OOP-koncept vi gått igenom i KMOM02:
                <br><br>
                <strong>Arv</strong>
                När en klass ärver från en annan så får den tillgång till alla ickeprivata attribut och metoder som föräldraklassen har.
                Den ärvande klassen får således samma beteende som föräldern och kan dessutom lägga till mer funktionalitet specifikt för den.
                <br><br> 
                <strong>Komposition</strong>
                Komposition och aggregation är två sätt att beskriva hur "bunda" klasser är till varandra.
                Om en klass relaterar till en annan med komposition så innebär det att en instans av denna inte kan existera på egen hand.
                Den kan bara existera i den klassen som den är medlem av.
                <br><br>
                <strong>Interface</strong>
                Ett interface beskriver ett kontrakt som en klass måste uppfylla. Specifikt beskriver den vilket beteende (metoder)
                en klass skall ha och inte vilka attribut (egenskaper) den skall ha. Om två klasser extendar ett interface så kan
                man vara säker på att båda klasserna minst uppfyller de beteenden som interfacet definierar.
                <br><br>
                <strong>Trait</strong>
                Trait finns till i PHP eftersom det inte stöder multipelt arv. Genom att använda traits så kan man definiera metoder som flera klasser kan använda sig av,
                oavsett om de är besläktade med varandra eller inte. Traits möjliggör därför flera klasser att ha samma beteende utan att behöva definiera samma metoder
                i alla dessa klasser.
                <br><br>
                <strong>Implementering</strong>
                Angående implementeringen av uppgiften så anser jag att den gick utan svårigheter. Jag är nöjd med min insats och programmet fungerar till belåtenhet.
                För att lösa uppgiften började jag med att skriva ner i vilken ordning jag skulle utföra saker. Dessutom specificerade jag vilka attribut och metoder
                som min klasser skulle ha för att önskat beteende skulle kunna uppnås. Därefter skapade jag en båda kontrollers och sidmallarna som skulle hysa alla data.
                När jag var klar med dessa moment började jag implementera attribut och metoder i mina klasser och skapade sedan routes som renderade sidmallar med data på.
                En förbättring jag ser är att tillåta användaren att blanda Card och CardGraphic i samma kortlek.
                Dock såg jag detta som lite överflödigt då CardGraphic erbjuder samma funktionalitet som Card.
                <br><br>
                Angående flödesdiagram och pseudokod så var det inget som uppgiften bad om. Därför tänkte jag i denna diskussion utgå från mitt UML-diagram.
                Jag tycker ofta att det är bra att modellera klasser i ett UML-diagram innan dessa implementeras.
                Genom att göra det kan jag abstrahera bort en hel del och enbart fokusera på hur klasserna skall se ut och bete sig,
                utan att behöva störas av hur de skall implementeras konkret. Jag tror definitivt att detta är ett stöd och att det förbättrar min problemlösningsförmåga.
                <br><br>
                Min TIL för detta kursmoment är en bättre förståelse för Symfony samt hur jag lägger till skräddarsytt beteende för json-serialisering på klassnivå.
            </p>
        </div>
        <div id="kmom03" class="report-card">
            <h3>Kmom03</h3>
            <p> 
                Jag tycker att Kmom03 har givit mig goda förutsättningar att öva på modellering och problemlösning med pseudokod och flödesdiagram. Jag anser att det har varit till stor nytta för mig och att det dessutom ökat kvaliteten på den kod jag producerat. Att modellera en applikation och tänka igenom den nog innan implementering är något som jag kommer att fortsätta med framöver. Jag anser att det hjälper mig i min problemlösning och att det asbtraherar bort implementeringsspecifika detaljer som annars kan sätta käppar i hjulen för problemlösningen i sig.
                <br><br>
                Gällande min implementering av kortspelet så tänkte jag först noga över hur jag skulle lösa uppgiften. Sedan började jag att översiktligt specificera vilka delar jag skulle lösa först. Därefter började jag skissa på de olika klassernas beteende och egenskaper, för att slutligen implementera dessa i en bestämd ordning. Jag fick göra en del justeringar under utvecklingen vilket händer mig i det flesta kursmoment. Justeringarna i detta kmom är sådana som har med spelets tillstånd att göra och ett exempel på detta är "CardGame::updateGameState()". Jag ville att hela spelets tillstånde skulle kunna uppdateras i en enda funktion och inte i flera separata funktioner.  Med hjälp av denna funktion uppnådde jag mitt mål och spelet blev lätt att hantera, utan rörig kod. Några saker som skulle kunna förbättras är CardGame::getWinner(), som är alldeles för rörig, och updateDealer / updatePlayer från samma klass. De två sistnämda borde jag kunna göra i en enskild funktion men har inte hittat något bra sätt att åstadkomma det på.
                <br><br>
                Hittills i kursen så tycker jag att Symfony som ramverk har varit ett stöd för mig. Det gör mycket bakom kulisserna och en hel del går på "automagi". Fördelen med detta är att jag slipper att tänka på implementeringsspecifika detaljer som annars hade tagit en del tid att utveckla på egen hand. Jag tycker att templatingsystemet fungerar bra men saknar intellisense i twigfilerna. Det hade underlättat att ha typinferens / autocomplete direkt i templates ungefär så som React / Vue med typescript fungerar. Dessa två är ju dock frontend-ramverk / -paket och inte baserade på PHP men man kan ju alltid önska.
                Jag är nöjd med min insats i kmom03 och anser att jag gjort det mesta med den tid jag hade disponibel. Mitt TIL för detta kursmoment är kodstandard och struktur i PHP samt tankesättet med tunna controllers och feta modeller.

            </p>
        </div>
        <div id="kmom04" class="report-card">
            <h3>Kmom04</h3>
            <h4>Enhetstestning</h4>
            <p> 
                <br><br>
                Detta kursmoment har varit ett av de nyttigaste i kursen hittills. Jag har fått insikt om vad testning i PHP med PHPunit innebär samt hur tester struktureras och konfigureras. Sedan innan har jag skrivit enhetstester i Node, Python och C# och det är intressant hur lik testprocessen är. Därför tycker jag att testning med PHPUnit har känts naturligt och lättsamt. Konfigurationen av programvaran har också gått utan problem och jag tycker att mycket varit intuitivt.
                <br><br>
                Gällande att skriva kod som testar annan kod så tycker jag att det är olika lätt / svårt beroende på hur koden som skall testas ser ut. Om det exempelvis finns mycket slumpmässigt beteende i funktioner så tycker jag att det är otroligt svårt att få till bra testfall. Om det däremot är fastställt vad en funktion skall returnera så är det ofta trivialt att testa den.
                <br><br>
                När jag ser till kodtäckning så lyckades jag få 100% i flera av mina klasser. Den enda som jag inte uppnådde detta i var CardGame, vilket berodde på att den har en del icke deterministiskt beteende som sätter rätt rejäla käppar i hjulen. Jag experimenterade med Mock objects och Stubs för att kunna simulera slumpmässigt beteende men kom snabbt fram till att de testfall där dessa användes inte var så meningsfulla. Därför slopade jag en del tester som jag inte ansåg uppfyllde ett syfte.
                <br><br>
                Jag tycker generellt att min kod är testbar och jag stötte inte på några problem bortsett från de som jag beskrev i föregående stycke. Jag skulle kunna åtgärda slumpmässiga beteenden för att göra koden mer testbar, men i detta sammanhang så skulle detta resultera i förlust av funktionalitet som faktiskt behövs för att applikationen skall fungera som tänkt. Med det sagt så valde jag trots allt att skriva om en del annan kod för att det skulle vara lättare att förstå den och därmed lättare att formulera testfall för. Den funktion som jag skrev om mest var CardGame::getWinner(), som i sitt grundutförande var nästintill obegriplig och onödigt komplicerad för vad den gjorde.
                <br><br>
                Om jag skall reflektera lite om hurvida testbar kod per automatik innebär "snygg och ren" kod så tänker jag att det beror på. Bara för att en funktion är lätt att testa så behöver det inte betyda att den är snyggt och strukturerat skriven. Exempelvis skulle funktionen kunna manipulera data på alla möjliga komplicerade sätt innan den till slut returnerar ett värde. Returvärdet i sig kanske enbart kan ha två former medans koden som bestämmer vilken form detta skall ha kan vara otroligt komplex. I ett sådant fall blir funktionen lätt att testa men svår att förstå sig på. Samtidigt skulle man kunna argumentera för att det i ett sådant fall vore intressant att göra fler "del-assertions" inne i funktionen för att kontrollera att data manipuleras på rätt sätt. Vilket i sådana fall skulle göra koden mer svårtestad och därmed stärka sambandet mellan testbar och snygg/strukturerad kod.
                <br><br>
                Mitt TIL för detta kursmoment är upplägget på testklasser med PHPUnit samt hur programvaran konfigureras.
            </p>
        </div>
        <div id="kmom05" class="report-card">
            <h3>Kmom05</h3>
            <h4>ORM</h4>
            <p> 
                <br><br>
                Övningen med symfony och doctrine gick bra att genomföra och jag kände igen upplägget från att ha arbetat med andra ORM.  Det är trevligt att kunna abstrahera bort interaktionen mot databasen och få ett mer deklarativt sätt att hantera denna istället. Något som jag tänkte på under övningen, som dock inte har med ORM specifikt att göra, är hur förvirrande OOP lätt blir när en klass ärver från mer än en klass i en kedja. Blandar man dessutom in interface så tycker jag att det lätt blir oöverskådligt och svårt att navigera i källkod för att hitta ärvda metoder. Detta är bara en kort reflektion om något som jag spontant kände under tiden jag arbetade med momentet och det har som sagt inget att göra med ORM specifikt utan snarare paradigmen i sig.
                <br><br>
                Gällande applikationen så gjorde jag den så enkel som möjligt. Målet var att det så få knapptryck som möjligt skall behövas när en användare skall kunna uträtta en uppgift. Jag försökte få interfacet så intuitivt som möjligt och även om det lämnar mycket att önska i form av design så är funktionaliteten där. Det enda stället som jag kände att jag behövde förtydliga var i tabellen med alla böcker. För att komma till en enskild bok så måste användaren klicka på id:t, men det framgår inte omedelbart i UI:t. Därför lade jag till en text över tabellen som förklarar hur användaren skall navigera. Dock så hade det troligtvis varit mer lämpligt att populera id-kolumnen med en grön knapp men den befintliga lösningen fungerar sannolikt också. Sammantaget så anser jag ändå att gränssnittet är relativt intuitivt och fungerar bra för vad det är.
                <br><br>
                När jag ser till att arbeta med ORM i CRUD så tycker jag att det abstraherar bort mycket av sådant som tar tid. Dessutom blir interaktionen med databasen mer deklarativ och jag slipper skriva SQL för varenda operation. Förutom detta så får jag också ett bra sätt att uppdatera databasens schema på, och behöver inte köra ALTER TABLE-statements för att lägga till ytterligare fält. Istället sköter ORM det åt mig med hjälp av migrationer, något som sparar mycket tid i kodskrivande och testande.
                <br><br>
                Sammanfattningsvis så ser jag ORM som ett bra sätt att abstrahera bort mycket av det som är besvärligt med databaser. Samtidigt förstår jag också att viss flexibilitet försvinner. Skulle det vara så att man kräver något som ens entiteter inte klarar av så är man dock fri att använda rå SQL, även om detta till viss det tar bort poängen med ett ORM. Effekten av att arbeta med ett ORM är att antalet kodrader som behövs minskar drastiskt. Som jag tidigare nämt så behöver man inte längre skriva långa SQL-satser utan kan i stället njuta av ett enkelt och lättförstått gränssnitt mot databasen.
                <br><br>
                Mitt TIL för detta kmom är hur frustrerande det kan vara med arv i många led samt hur doctrine fungerar och underlättar interaktion mot en databas.
            </p>
        </div>
        <div id="kmom06" class="report-card">
            <h3>Kmom06</h3>
            <p> 
                <strong>KMOM 06</strong>
                Jag tycker att phpmetrics är en trevlig programvara som jag kan se mig själv använda i framtiden om jag använder PHP. Det ger värdefulla insikter och strukturerar informationen på ett bra sätt, även om jag önskar att det fanns bättre förklaringar av de saker den mäter. Under kursmomentets gång fick jag googla en hel del och ta information från externa sidor för att förstå innebörden av mätvärdena. Trots detta tycker jag programmet fungerar bra i sin helhet. Jag fastnade framförallt för relativ systemkomplexitet eftersom denna tar hänsyn till alla metoder i en klass samt komplexiteten dessa i mellan. Det är ett bra mått på hur en komplex en komponent är i genomsnitt och därmed ett bra mått på hur lätt / svår den är att underhålla. En annan funktion som jag blev förtjust i är Mantainability / complexity på phpmetrics "Overview"-sida. Där kan man se olika stora cirklar i olika färger som symboliserar cyklomatisk komplexitet samt "maintainability index".
                <br><br>
                Gällande scrutinizer så gick integrationen mot mitt repo relativt smärtfritt. Jag hade en del problem med att scrutinizer inte kunde köra composer install. Det visade sig bero på en avsaknad av env-fil i repot, något som jag hade konfigurerat tidigt i projektets skede. När denna väl var på plats så fungerade vertyget som väntat. Efter att ha använt vertyget ett tag så skulle jag säga att jag utan tvekan kommer koppla detta mot andra projekt när tillfälle uppenbarar sig. Det är synnerligen värdefullt med automatisk testning och emblemen som kan läggas till i readmefilen är en trevlig bonus de också. Jag uppnådde 36% i kodtecking i min första körning samt 9.97 / 10 i kodkvalitet.
                <br><br>
                Gällande kodkvalitet och min syn på den så har jag några saker jag brukar tänka på när begreppet tas upp. Jag tycker att det mest grundläggande är att skriva kod som är lätt att underhålla och som i princip dokumenterar sig själv. Jag anser att det är viktigt att inte fastna i tanken om att man skall skriva så kompakt kod som möjligt, utan att denna istället skall vara lätt att förstå och göra ändringar i. Dessutom tycker jag att man bör kommentera sin kod lagom, så att inte kommentarerna i sig gör koden besvärlig att läsa. Allmänt tycker jag att det är bättre att kommentera varför man gör något och inte vad man gör. Undantag finns, så som docblocks i PHP. Sedan tror jag också att testning är en central del av att faktiskt verifiera att ens kod håller den standard som man själv tror att den gör. Att också få ett bevis på detta i form av badges är ett bra sätt att informera andra om att ens kod håller en viss kvalitet.
            </p>
        </div>
    </section>
{% endblock %}